---
import type { Live2DModelConfig } from "../../types/config";

interface Props {
  config: Live2DModelConfig;
}

const { config } = Astro.props;

// 获取位置和尺寸配置
const position = config.position || {
  corner: "bottom-right" as const,
  offsetX: 20,
  offsetY: 20,
};
const size = config.size || { width: 280, height: 250 };
---

<div
  id="live2d-widget"
  class="live2d-widget"
  style={` 
    width: ${size.width}px;
    height: ${size.height}px;
    ${position.corner?.includes("right") ? "right" : "left"}: ${position.offsetX}px;
    ${position.corner?.includes("top") ? "top" : "bottom"}: ${position.offsetY}px;
  `}
>
  <canvas id="live2d-canvas" width={size.width} height={size.height}></canvas>
</div>

<script define:vars={{ config }}>
  let modelData = null;
  let motionGroups = {};
  let hitAreas = {};
  let currentMotionGroup = "idle";
  let currentMotionIndex = 0;

  // Use loadlive2d function from the working project
  function initLive2D() {
    if (!window.loadlive2d) {
      console.error("loadlive2d function not available");
      return;
    }

    if (!config.model || !config.model.path) {
      console.error("No model path configured");
      return;
    }

    const modelPath = config.model.path;

    // Load model data first to get motion groups and hit areas
    fetch(modelPath)
      .then((response) => response.json())
      .then((data) => {
        modelData = data;
        motionGroups = data.motions || {};
        hitAreas = data.hit_areas_custom || data.hit_areas || {};

        console.log("Loaded model data:", {
          motionGroups: Object.keys(motionGroups),
          hitAreas: Object.keys(hitAreas),
        });

        // Load the model using loadlive2d
        window.loadlive2d("live2d-canvas", modelPath);

        // Setup interactions after a delay to ensure model is loaded
        setTimeout(() => {
          setupInteractions();
        }, 2000);
      })
      .catch((error) => {
        console.error("Failed to load model data:", error);
      });
  }

  // Setup click interactions and drag functionality
  function setupInteractions() {
    const canvas = document.getElementById("live2d-canvas");
    const container = document.getElementById("live2d-widget");
    if (!canvas || !container) return;

    canvas.addEventListener("click", handleClick);

    // 添加拖拽功能
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let containerStart = { x: 0, y: 0 };

    // 鼠标事件
    container.addEventListener("mousedown", (e) => {
      if (e.button !== 0) return; // 只响应左键
      isDragging = true;
      dragStart = { x: e.clientX, y: e.clientY };

      const rect = container.getBoundingClientRect();
      containerStart = { x: rect.left, y: rect.top };

      container.style.cursor = "grabbing";
      e.preventDefault();
    });

    document.addEventListener("mousemove", (e) => {
      if (!isDragging) return;

      const deltaX = e.clientX - dragStart.x;
      const deltaY = e.clientY - dragStart.y;

      const newX = containerStart.x + deltaX;
      const newY = containerStart.y + deltaY;

      // 边界检查
      const maxX = window.innerWidth - container.offsetWidth;
      const maxY = window.innerHeight - container.offsetHeight;

      const clampedX = Math.max(0, Math.min(newX, maxX));
      const clampedY = Math.max(0, Math.min(newY, maxY));

      container.style.left = clampedX + "px";
      container.style.right = "auto";
      container.style.top = clampedY + "px";
      container.style.bottom = "auto";
    });

    document.addEventListener("mouseup", () => {
      if (isDragging) {
        isDragging = false;
        container.style.cursor = "grab";
      }
    });

    // 触摸事件（移动端支持）
    container.addEventListener("touchstart", (e) => {
      if (e.touches.length !== 1) return;
      isDragging = true;
      const touch = e.touches[0];
      dragStart = { x: touch.clientX, y: touch.clientY };

      const rect = container.getBoundingClientRect();
      containerStart = { x: rect.left, y: rect.top };

      e.preventDefault();
    });

    document.addEventListener("touchmove", (e) => {
      if (!isDragging || e.touches.length !== 1) return;

      const touch = e.touches[0];
      const deltaX = touch.clientX - dragStart.x;
      const deltaY = touch.clientY - dragStart.y;

      const newX = containerStart.x + deltaX;
      const newY = containerStart.y + deltaY;

      // 边界检查
      const maxX = window.innerWidth - container.offsetWidth;
      const maxY = window.innerHeight - container.offsetHeight;

      const clampedX = Math.max(0, Math.min(newX, maxX));
      const clampedY = Math.max(0, Math.min(newY, maxY));

      container.style.left = clampedX + "px";
      container.style.right = "auto";
      container.style.top = clampedY + "px";
      container.style.bottom = "auto";

      e.preventDefault();
    });

    document.addEventListener("touchend", () => {
      isDragging = false;
    });

    // 设置初始光标样式
    container.style.cursor = "grab";

    // 窗口大小变化时重新检查边界
    window.addEventListener("resize", () => {
      const rect = container.getBoundingClientRect();
      const maxX = window.innerWidth - container.offsetWidth;
      const maxY = window.innerHeight - container.offsetHeight;

      if (rect.left > maxX) {
        container.style.left = maxX + "px";
        container.style.right = "auto";
      }
      if (rect.top > maxY) {
        container.style.top = maxY + "px";
        container.style.bottom = "auto";
      }
    });

    console.log("Live2D interactions and drag functionality setup complete");
  }

  // Handle click events
  function handleClick(event) {
    if (!motionGroups || Object.keys(motionGroups).length === 0) {
      console.log("No motion groups available");
      return;
    }

    const rect = event.target.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    // Convert to normalized coordinates
    const normalizedX = (x / rect.width) * 2 - 1;
    const normalizedY = -((y / rect.height) * 2 - 1);

    console.log("Click at:", { x: normalizedX, y: normalizedY });

    // Determine which motion to play based on hit areas
    let motionGroup = "tap_body"; // default

    // Check head area
    if (hitAreas.head_x && hitAreas.head_y) {
      const [headXMin, headXMax] = hitAreas.head_x;
      const [headYMin, headYMax] = hitAreas.head_y;

      if (
        normalizedX >= headXMin &&
        normalizedX <= headXMax &&
        normalizedY >= headYMin &&
        normalizedY <= headYMax
      ) {
        motionGroup = "flick_head";
        console.log("Head area clicked - playing flick_head motion");
      }
    }

    // Check body area (if not head)
    if (motionGroup === "tap_body" && hitAreas.body_x && hitAreas.body_y) {
      const [bodyXMin, bodyXMax] = hitAreas.body_x;
      const [bodyYMin, bodyYMax] = hitAreas.body_y;

      if (
        normalizedX >= bodyXMin &&
        normalizedX <= bodyXMax &&
        normalizedY >= bodyYMin &&
        normalizedY <= bodyYMax
      ) {
        console.log("Body area clicked - playing tap_body motion");
      }
    }

    // Play motion
    playMotion(motionGroup);

    // Show message
    showMessage();
  }

  // 全局变量，跟踪当前显示的消息容器和隐藏定时器
  let currentMessageContainer = null;
  let hideMessageTimer = null;

  // Show random message with advanced styling (same as Spine)
  function showMessage() {
    const messages = config.interactive?.clickMessages || [
      "你好！伊利雅~",
      "有什么需要帮助的吗？",
      "今天天气真不错呢！",
      "要不要一起玩游戏？",
      "记得按时休息哦！",
    ];

    const randomMessage = messages[Math.floor(Math.random() * messages.length)];

    // 防止空消息或重复调用
    if (!randomMessage || !randomMessage.trim()) {
      return;
    }

    // 立即清除之前的消息
    if (currentMessageContainer) {
      clearTimeout(hideMessageTimer);
      if (currentMessageContainer.parentNode) {
        currentMessageContainer.parentNode.removeChild(currentMessageContainer);
      }
      currentMessageContainer = null;
    }

    // 确保DOM中没有残留的消息容器
    const existingMessages = document.querySelectorAll(
      ".live2d-message-container"
    );
    existingMessages.forEach((msg) => {
      if (msg.parentNode) {
        msg.parentNode.removeChild(msg);
      }
    });

    // 检测暗色主题
    const isDarkMode =
      document.documentElement.classList.contains("dark") ||
      window.matchMedia("(prefers-color-scheme: dark)").matches;

    // 创建消息容器
    const messageContainer = document.createElement("div");
    messageContainer.className = "live2d-message-container";

    // 创建消息元素
    const messageEl = document.createElement("div");
    messageEl.className = "live2d-message";
    messageEl.textContent = randomMessage;

    // 创建箭头元素
    const arrowEl = document.createElement("div");
    arrowEl.className = "live2d-message-arrow";

    // 设置容器样式
    Object.assign(messageContainer.style, {
      position: "fixed",
      zIndex: "1001",
      pointerEvents: "none",
      opacity: "0",
      transform: "translateY(15px) translateX(-50%) scale(0.9)",
      transition: "all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1)",
    });

    // 设置消息框美化样式（支持暗色主题）
    const messageStyles = {
      position: "relative",
      background: isDarkMode
        ? "linear-gradient(135deg, rgba(45, 55, 72, 0.95), rgba(26, 32, 44, 0.9))"
        : "linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(240, 248, 255, 0.9))",
      color: isDarkMode ? "#e2e8f0" : "#2c3e50",
      padding: "12px 16px",
      borderRadius: "16px",
      fontSize: "14px",
      fontWeight: "500",
      fontFamily:
        '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
      maxWidth: "240px",
      minWidth: "100px",
      wordWrap: "break-word",
      textAlign: "center",
      whiteSpace: "pre-wrap",
      boxShadow: isDarkMode
        ? "0 8px 32px rgba(0, 0, 0, 0.3), 0 2px 8px rgba(0, 0, 0, 0.2)"
        : "0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(0, 0, 0, 0.08)",
      border: isDarkMode
        ? "1px solid rgba(255, 255, 255, 0.1)"
        : "1px solid rgba(255, 255, 255, 0.6)",
      backdropFilter: "blur(12px)",
      letterSpacing: "0.3px",
      lineHeight: "1.4",
    };
    Object.assign(messageEl.style, messageStyles);

    // 设置箭头样式（居中显示）
    Object.assign(arrowEl.style, {
      position: "absolute",
      top: "100%",
      left: "50%",
      transform: "translateX(-50%)", // 箭头居中
      width: "0",
      height: "0",
      borderLeft: "8px solid transparent",
      borderRight: "8px solid transparent",
      borderTop: isDarkMode
        ? "8px solid rgba(45, 55, 72, 0.95)"
        : "8px solid rgba(255, 255, 255, 0.95)",
      filter: "drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1))",
    });

    // 组装消息框元素
    messageEl.appendChild(arrowEl);
    messageContainer.appendChild(messageEl);

    // 添加到页面并保存引用
    document.body.appendChild(messageContainer);
    currentMessageContainer = messageContainer;

    // 将消息显示在 Live2D 模型头顶居中
    const container = document.getElementById("live2d-widget");
    if (container) {
      const rect = container.getBoundingClientRect();

      // 消息框居中显示在模型上方
      const containerCenterX = rect.left + rect.width / 2;

      // 使用估算的消息框尺寸进行初步定位
      const estimatedMessageWidth = 240; // 使用maxWidth作为估算
      const estimatedMessageHeight = 60; // 估算高度
      const screenPadding = 10; // 距离屏幕边缘的最小距离

      // 计算消息框的实际位置（考虑translateX(-50%)的影响）
      let messageX = containerCenterX;
      let messageY = rect.top - estimatedMessageHeight - 25; // 距离模型顶部25px

      // 屏幕边界检查 - 水平方向
      const minX = screenPadding + estimatedMessageWidth / 2; // 考虑translateX(-50%)
      const maxX =
        window.innerWidth - screenPadding - estimatedMessageWidth / 2;

      if (messageX < minX) {
        messageX = minX;
      } else if (messageX > maxX) {
        messageX = maxX;
      }

      // 屏幕边界检查 - 垂直方向
      const minY = screenPadding;
      const maxY = window.innerHeight - estimatedMessageHeight - screenPadding;

      if (messageY < minY) {
        // 如果上方空间不够，显示在模型下方
        messageY = rect.bottom + 25;
        // 调整箭头方向（显示在下方）
        arrowEl.style.top = "0";
        arrowEl.style.bottom = "auto";
        arrowEl.style.borderTop = "none";
        arrowEl.style.borderBottom = isDarkMode
          ? "8px solid rgba(45, 55, 72, 0.95)"
          : "8px solid rgba(255, 255, 255, 0.95)";
      } else if (messageY > maxY) {
        messageY = maxY;
      }

      // 设置位置
      messageContainer.style.left = messageX + "px";
      messageContainer.style.top = messageY + "px";

      // 在消息框渲染后，进行精确的边界调整
      setTimeout(() => {
        const actualMessageRect = messageContainer.getBoundingClientRect();
        const actualWidth = actualMessageRect.width;
        const actualHeight = actualMessageRect.height;

        // 重新计算水平位置
        let adjustedX = containerCenterX;
        const actualMinX = screenPadding + actualWidth / 2;
        const actualMaxX = window.innerWidth - screenPadding - actualWidth / 2;

        if (adjustedX < actualMinX) {
          adjustedX = actualMinX;
        } else if (adjustedX > actualMaxX) {
          adjustedX = actualMaxX;
        }

        // 重新计算垂直位置
        let adjustedY = rect.top - actualHeight - 25;
        const actualMinY = screenPadding;
        const actualMaxY = window.innerHeight - actualHeight - screenPadding;
        let isAboveModel = true; // 标记消息框是否在模型上方

        if (adjustedY < actualMinY) {
          adjustedY = rect.bottom + 25;
          isAboveModel = false;
        } else if (adjustedY > actualMaxY) {
          adjustedY = actualMaxY;
        }

        // 计算箭头应该指向的位置（模型中心）
        const modelCenterX = rect.left + rect.width / 2;
        const messageCenterX = adjustedX; // 消息框中心位置
        const arrowOffsetX = modelCenterX - messageCenterX; // 箭头相对于消息框中心的偏移

        // 限制箭头偏移范围，避免超出消息框边界
        const maxOffset = actualWidth / 2 - 20; // 留出20px边距
        const clampedOffsetX = Math.max(
          -maxOffset,
          Math.min(maxOffset, arrowOffsetX)
        );

        // 根据最终位置调整箭头方向和位置
        if (isAboveModel) {
          // 消息框在模型上方，箭头向下
          Object.assign(arrowEl.style, {
            position: "absolute",
            top: "100%",
            left: "50%",
            bottom: "auto",
            transform: `translateX(calc(-50% + ${clampedOffsetX}px))`,
            width: "0",
            height: "0",
            borderLeft: "8px solid transparent",
            borderRight: "8px solid transparent",
            borderTop: isDarkMode
              ? "8px solid rgba(45, 55, 72, 0.95)"
              : "8px solid rgba(255, 255, 255, 0.95)",
            borderBottom: "none",
            filter: "drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1))",
          });
        } else {
          // 消息框在模型下方，箭头向上
          Object.assign(arrowEl.style, {
            position: "absolute",
            top: "0",
            left: "50%",
            bottom: "auto",
            transform: `translateX(calc(-50% + ${clampedOffsetX}px))`,
            width: "0",
            height: "0",
            borderLeft: "8px solid transparent",
            borderRight: "8px solid transparent",
            borderTop: "none",
            borderBottom: isDarkMode
              ? "8px solid rgba(45, 55, 72, 0.95)"
              : "8px solid rgba(255, 255, 255, 0.95)",
            filter: "drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1))",
          });
        }

        // 应用调整后的位置
        messageContainer.style.left = adjustedX + "px";
        messageContainer.style.top = adjustedY + "px";
      }, 50); // 增加延迟确保消息框完全渲染
    }

    // 显示动画
    setTimeout(() => {
      messageContainer.style.opacity = "1";
      messageContainer.style.transform =
        "translateY(0) translateX(-50%) scale(1)";
    }, 100); // 延迟到边界调整完成后

    // 自动隐藏
    const displayTime = config.interactive?.messageDisplayTime || 3000;
    hideMessageTimer = setTimeout(() => {
      messageContainer.style.opacity = "0";
      messageContainer.style.transform =
        "translateY(-15px) translateX(-50%) scale(0.95)";
      setTimeout(() => {
        if (messageContainer.parentNode) {
          messageContainer.parentNode.removeChild(messageContainer);
        }
        // 清除引用
        if (currentMessageContainer === messageContainer) {
          currentMessageContainer = null;
        }
      }, 400);
    }, displayTime);
  }

  // Play motion from a specific group
  function playMotion(groupName) {
    if (!motionGroups[groupName] || motionGroups[groupName].length === 0) {
      console.log(`No motions available for group: ${groupName}`);
      // Fallback to any available motion group
      const availableGroups = Object.keys(motionGroups).filter(
        (key) => motionGroups[key].length > 0
      );
      if (availableGroups.length > 0) {
        groupName = availableGroups[0];
        console.log(`Using fallback group: ${groupName}`);
      } else {
        return;
      }
    }

    const motions = motionGroups[groupName];
    let motionIndex;

    if (groupName === currentMotionGroup) {
      // Cycle through motions in the same group
      currentMotionIndex = (currentMotionIndex + 1) % motions.length;
      motionIndex = currentMotionIndex;
    } else {
      // Random motion from new group
      motionIndex = Math.floor(Math.random() * motions.length);
      currentMotionIndex = motionIndex;
    }

    currentMotionGroup = groupName;

    console.log(`Playing motion ${motionIndex} from group ${groupName}`);

    // Trigger motion change by reloading model with different parameters
    // This is a workaround since we can't directly control motions in loadlive2d
    const canvas = document.getElementById("live2d-canvas");
    if (canvas && window.loadlive2d) {
      // Add motion info to canvas data for potential future use
      canvas.dataset.currentMotionGroup = groupName;
      canvas.dataset.currentMotionIndex = motionIndex;

      // Trigger a visual feedback
      canvas.style.transform = "scale(1.05)";
      setTimeout(() => {
        canvas.style.transform = "scale(1)";
      }, 150);
    }
  }

  // Load Live2D and initialize
  function loadLive2DSDK() {
    // Check if Live2D SDK is already loaded
    if (window.loadlive2d) {
      initLive2D();
      return;
    }

    // Load Live2D SDK
    const script = document.createElement("script");
    script.src = "/pio/static/live2d-sdk/live2d.min.js";
    script.onload = () => {
      // Wait a bit for the SDK to initialize
      setTimeout(() => {
        if (window.loadlive2d) {
          initLive2D();
        } else {
          console.error("loadlive2d function not found after loading SDK");
        }
      }, 100);
    };
    script.onerror = () => {
      console.error("Failed to load Live2D SDK");
    };
    document.head.appendChild(script);
  }

  // Handle responsive display
  function handleResponsive() {
    const widget = document.getElementById("live2d-widget");
    if (!widget) return;

    const responsive = config.responsive;
    if (responsive?.hideOnMobile) {
      const breakpoint = responsive.mobileBreakpoint || 768;
      if (window.innerWidth <= breakpoint) {
        widget.style.display = "none";
      } else {
        widget.style.display = "block";
      }
    }
  }

  // Initialize when ready (only once)
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => {
      // 检查是否已经初始化
      if (!window.live2dModelInitialized) {
        loadLive2DSDK();
        window.live2dModelInitialized = true;
      }
      handleResponsive();
    });
  } else {
    // 检查是否已经初始化
    if (!window.live2dModelInitialized) {
      loadLive2DSDK();
      window.live2dModelInitialized = true;
    }
    handleResponsive();
  }

  // Handle window resize for responsive behavior
  window.addEventListener("resize", handleResponsive);

  // 监听 Swup 页面切换事件（如果使用了 Swup）
  if (typeof window.swup !== "undefined" && window.swup.hooks) {
    window.swup.hooks.on("content:replace", () => {
      // 只更新响应式显示，不重新创建模型
      setTimeout(() => {
        handleResponsive();
      }, 100);
    });
  } else {
    // 如果 Swup 还未加载，监听启用事件
    document.addEventListener("swup:enable", () => {
      if (window.swup && window.swup.hooks) {
        window.swup.hooks.on("content:replace", () => {
          setTimeout(() => {
            handleResponsive();
          }, 100);
        });
      }
    });
  }
</script>

<style>
  .live2d-widget {
    position: fixed;
    z-index: 999;
    pointer-events: auto; /* 启用指针事件以支持拖拽 */
    cursor: grab; /* 默认显示拖拽光标 */
  }

  #live2d-canvas {
    pointer-events: auto;
    cursor: pointer;
    transition: all 0.3s ease;
    width: 100%;
    height: 100%;
  }

  .live2d-widget:hover #live2d-canvas {
    opacity: 1;
  }

  /* 拖拽时的光标样式 */
  .live2d-widget:active {
    cursor: grabbing;
  }
</style>
