---
import { spineModelConfig } from "../../config/pioConfig";
---

<!-- Spine Web Player CSS 将在 script 中动态加载 -->{
  spineModelConfig.enable && (
    <div
      id="spine-model-container"
      style={`
      position: fixed;
      ${spineModelConfig.position.corner.includes("right") ? "right" : "left"}: ${spineModelConfig.position.offsetX}px;
      ${spineModelConfig.position.corner.includes("top") ? "top" : "bottom"}: ${spineModelConfig.position.offsetY}px;
      width: ${spineModelConfig.size.width}px;
      height: ${spineModelConfig.size.height}px;
      pointer-events: auto;
      z-index: 1000;
    `}
    >
      <div id="spine-player-container" style="width: 100%; height: 100%;" />
      <div id="spine-error" style="display: none;" />
    </div>
  )
}

<script define:vars={{ spineModelConfig }}>
  // 动态加载 Spine CSS（带本地备用）
  function loadSpineCSS() {
    if (!spineModelConfig.enable) return;

    // 检查是否已经加载
    const existingLink = document.querySelector('link[href*="spine-player"]');
    if (existingLink) return;

    // 首先尝试加载 CDN CSS
    const cdnLink = document.createElement("link");
    cdnLink.rel = "stylesheet";
    cdnLink.href =
      "https://unpkg.com/@esotericsoftware/spine-player@4.2.*/dist/spine-player.min.css";

    // 监听加载失败事件，自动回退到本地文件
    cdnLink.onerror = function () {
      console.warn("⚠️ Spine CSS CDN failed, trying local fallback...");

      // 移除失败的 CDN link
      if (cdnLink.parentNode) {
        cdnLink.parentNode.removeChild(cdnLink);
      }

      // 创建本地备用 CSS link
      const localLink = document.createElement("link");
      localLink.rel = "stylesheet";
      localLink.href = "/pio/static/spine-player.min.css";
      localLink.onerror = function () {
        console.error("❌ Failed to load Spine CSS");
      };

      document.head.appendChild(localLink);
    };

    document.head.appendChild(cdnLink);
  }

  // 全局变量，跟踪当前显示的消息容器和隐藏定时器
  let currentMessageContainer = null;
  let hideMessageTimer = null;
  let isClickProcessing = false; // 防止重复点击的标志
  let lastClickTime = 0; // 记录最后一次点击时间

  // 全局变量，防止重复初始化
  window.spineModelInitialized = window.spineModelInitialized || false;
  window.spinePlayerInstance = window.spinePlayerInstance || null;

  // 消息显示函数
  function showMessage(message) {
    // 防止空消息或重复调用
    if (!message || !message.trim()) {
      return;
    }

    // 立即清除之前的消息
    if (currentMessageContainer) {
      clearTimeout(hideMessageTimer);
      if (currentMessageContainer.parentNode) {
        currentMessageContainer.parentNode.removeChild(currentMessageContainer);
      }
      currentMessageContainer = null;
    }

    // 确保DOM中没有残留的消息容器
    const existingMessages = document.querySelectorAll(
      ".spine-message-container"
    );
    existingMessages.forEach((msg) => {
      if (msg.parentNode) {
        msg.parentNode.removeChild(msg);
      }
    });
    // 检测暗色主题
    const isDarkMode =
      document.documentElement.classList.contains("dark") ||
      window.matchMedia("(prefers-color-scheme: dark)").matches;

    // 创建消息容器
    const messageContainer = document.createElement("div");
    messageContainer.className = "spine-message-container";

    // 创建消息元素
    const messageEl = document.createElement("div");
    messageEl.className = "spine-message";
    messageEl.textContent = message;

    // 创建箭头元素
    const arrowEl = document.createElement("div");
    arrowEl.className = "spine-message-arrow";

    // 设置容器样式
    Object.assign(messageContainer.style, {
      position: "fixed",
      zIndex: "1001",
      pointerEvents: "none",
      opacity: "0",
      transform: "translateY(15px) translateX(-50%) scale(0.9)",
      transition: "all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1)",
    });

    // 设置消息框美化样式（支持暗色主题）
    const messageStyles = {
      position: "relative",
      background: isDarkMode
        ? "linear-gradient(135deg, rgba(45, 55, 72, 0.95), rgba(26, 32, 44, 0.9))"
        : "linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(240, 248, 255, 0.9))",
      color: isDarkMode ? "#e2e8f0" : "#2c3e50",
      padding: "12px 16px",
      borderRadius: "16px",
      fontSize: "14px",
      fontWeight: "500",
      fontFamily:
        '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
      maxWidth: "240px",
      minWidth: "100px",
      wordWrap: "break-word",
      textAlign: "center",
      whiteSpace: "pre-wrap",
      boxShadow: isDarkMode
        ? "0 8px 32px rgba(0, 0, 0, 0.3), 0 2px 8px rgba(0, 0, 0, 0.2)"
        : "0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(0, 0, 0, 0.08)",
      border: isDarkMode
        ? "1px solid rgba(255, 255, 255, 0.1)"
        : "1px solid rgba(255, 255, 255, 0.6)",
      backdropFilter: "blur(12px)",
      letterSpacing: "0.3px",
      lineHeight: "1.4",
    };
    Object.assign(messageEl.style, messageStyles);

    // 设置箭头样式（居中显示）
    Object.assign(arrowEl.style, {
      position: "absolute",
      top: "100%",
      left: "50%",
      transform: "translateX(-50%)", // 箭头居中
      width: "0",
      height: "0",
      borderLeft: "8px solid transparent",
      borderRight: "8px solid transparent",
      borderTop: isDarkMode
        ? "8px solid rgba(45, 55, 72, 0.95)"
        : "8px solid rgba(255, 255, 255, 0.95)",
      filter: "drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1))",
    });

    // 组装消息框元素
    messageEl.appendChild(arrowEl);
    messageContainer.appendChild(messageEl);

    // 添加到页面并保存引用
    document.body.appendChild(messageContainer);
    currentMessageContainer = messageContainer;

    // 将消息显示在 firefly 头顶居中
    const container = document.getElementById("spine-model-container");
    if (container) {
      const rect = container.getBoundingClientRect();

      // 消息框居中显示在模型上方
      const containerCenterX = rect.left + rect.width / 2;

      // 使用估算的消息框尺寸进行初步定位
      const estimatedMessageWidth = 240; // 使用maxWidth作为估算
      const estimatedMessageHeight = 60; // 估算高度
      const screenPadding = 10; // 距离屏幕边缘的最小距离

      // 计算消息框的实际位置（考虑translateX(-50%)的影响）
      let messageX = containerCenterX;
      let messageY = rect.top - estimatedMessageHeight - 25; // 距离模型顶部25px

      // 屏幕边界检查 - 水平方向
      const minX = screenPadding + estimatedMessageWidth / 2; // 考虑translateX(-50%)
      const maxX =
        window.innerWidth - screenPadding - estimatedMessageWidth / 2;

      if (messageX < minX) {
        messageX = minX;
      } else if (messageX > maxX) {
        messageX = maxX;
      }

      // 屏幕边界检查 - 垂直方向
      const minY = screenPadding;
      const maxY = window.innerHeight - estimatedMessageHeight - screenPadding;

      if (messageY < minY) {
        // 如果上方空间不够，显示在模型下方
        messageY = rect.bottom + 25;
        // 调整箭头方向（显示在下方）
        arrowEl.style.top = "0";
        arrowEl.style.bottom = "auto";
        arrowEl.style.borderTop = "none";
        arrowEl.style.borderBottom = isDarkMode
          ? "8px solid rgba(45, 55, 72, 0.95)"
          : "8px solid rgba(255, 255, 255, 0.95)";
      } else if (messageY > maxY) {
        messageY = maxY;
      }

      // 设置位置
      messageContainer.style.left = messageX + "px";
      messageContainer.style.top = messageY + "px";

      // 在消息框渲染后，进行精确的边界调整
      setTimeout(() => {
        const actualMessageRect = messageContainer.getBoundingClientRect();
        const actualWidth = actualMessageRect.width;
        const actualHeight = actualMessageRect.height;

        // 重新计算水平位置
        let adjustedX = containerCenterX;
        const actualMinX = screenPadding + actualWidth / 2;
        const actualMaxX = window.innerWidth - screenPadding - actualWidth / 2;

        if (adjustedX < actualMinX) {
          adjustedX = actualMinX;
        } else if (adjustedX > actualMaxX) {
          adjustedX = actualMaxX;
        }

        // 重新计算垂直位置
        let adjustedY = rect.top - actualHeight - 25;
        const actualMinY = screenPadding;
        const actualMaxY = window.innerHeight - actualHeight - screenPadding;
        let isAboveModel = true; // 标记消息框是否在模型上方

        if (adjustedY < actualMinY) {
          adjustedY = rect.bottom + 25;
          isAboveModel = false;
        } else if (adjustedY > actualMaxY) {
          adjustedY = actualMaxY;
        }

        // 计算箭头应该指向的位置（模型中心）
        const modelCenterX = rect.left + rect.width / 2;
        const messageCenterX = adjustedX; // 消息框中心位置
        const arrowOffsetX = modelCenterX - messageCenterX; // 箭头相对于消息框中心的偏移

        // 限制箭头偏移范围，避免超出消息框边界
        const maxOffset = actualWidth / 2 - 20; // 留出20px边距
        const clampedOffsetX = Math.max(
          -maxOffset,
          Math.min(maxOffset, arrowOffsetX)
        );

        // 根据最终位置调整箭头方向和位置
        if (isAboveModel) {
          // 消息框在模型上方，箭头向下
          Object.assign(arrowEl.style, {
            position: "absolute",
            top: "100%",
            left: "50%",
            bottom: "auto",
            transform: `translateX(calc(-50% + ${clampedOffsetX}px))`,
            width: "0",
            height: "0",
            borderLeft: "8px solid transparent",
            borderRight: "8px solid transparent",
            borderTop: isDarkMode
              ? "8px solid rgba(45, 55, 72, 0.95)"
              : "8px solid rgba(255, 255, 255, 0.95)",
            borderBottom: "none",
            filter: "drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1))",
          });
        } else {
          // 消息框在模型下方，箭头向上
          Object.assign(arrowEl.style, {
            position: "absolute",
            top: "0",
            left: "50%",
            bottom: "auto",
            transform: `translateX(calc(-50% + ${clampedOffsetX}px))`,
            width: "0",
            height: "0",
            borderLeft: "8px solid transparent",
            borderRight: "8px solid transparent",
            borderTop: "none",
            borderBottom: isDarkMode
              ? "8px solid rgba(45, 55, 72, 0.95)"
              : "8px solid rgba(255, 255, 255, 0.95)",
            filter: "drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1))",
          });
        }

        // 应用调整后的位置
        messageContainer.style.left = adjustedX + "px";
        messageContainer.style.top = adjustedY + "px";
      }, 50); // 增加延迟确保消息框完全渲染
    }

    // 显示动画
    setTimeout(() => {
      messageContainer.style.opacity = "1";
      messageContainer.style.transform =
        "translateY(0) translateX(-50%) scale(1)";
    }, 100); // 延迟到边界调整完成后

    // 自动隐藏
    const displayTime = spineModelConfig.interactive.messageDisplayTime || 3000;
    hideMessageTimer = setTimeout(() => {
      messageContainer.style.opacity = "0";
      messageContainer.style.transform =
        "translateY(-15px) translateX(-50%) scale(0.95)";
      setTimeout(() => {
        if (messageContainer.parentNode) {
          messageContainer.parentNode.removeChild(messageContainer);
        }
        // 清除引用
        if (currentMessageContainer === messageContainer) {
          currentMessageContainer = null;
        }
      }, 400);
    }, displayTime);
  }

  // 更新响应式显示
  function updateResponsiveDisplay() {
    if (!spineModelConfig.enable) return;

    const container = document.getElementById("spine-model-container");
    if (!container) return;

    // 检查移动端显示设置
    if (
      spineModelConfig.responsive.hideOnMobile &&
      window.innerWidth <= spineModelConfig.responsive.mobileBreakpoint
    ) {
      container.style.display = "none";
    } else {
      container.style.display = "block";
    }
  }

  // 清理函数
  function cleanupSpineModel() {
    console.log("🧹 Cleaning up existing Spine model...");

    // 清理现有的消息显示
    if (currentMessageContainer) {
      clearTimeout(hideMessageTimer);
      if (currentMessageContainer.parentNode) {
        currentMessageContainer.parentNode.removeChild(currentMessageContainer);
      }
      currentMessageContainer = null;
    }

    // 清理所有消息容器
    const existingMessages = document.querySelectorAll(
      ".spine-message-container"
    );
    existingMessages.forEach((msg) => {
      if (msg.parentNode) {
        msg.parentNode.removeChild(msg);
      }
    });

    // 清理现有的播放器实例
    if (window.spinePlayerInstance) {
      try {
        if (window.spinePlayerInstance.dispose) {
          window.spinePlayerInstance.dispose();
        }
      } catch (e) {
        console.warn("Error disposing spine player:", e);
      }
      window.spinePlayerInstance = null;
    }

    // 清理容器内容
    const playerContainer = document.getElementById("spine-player-container");
    if (playerContainer) {
      playerContainer.innerHTML = "";
    }

    // 重置初始化标志
    window.spineModelInitialized = false;
  }

  async function initSpineModel() {
    if (!spineModelConfig.enable) return;

    // 检查是否已经初始化
    if (window.spineModelInitialized) {
      console.log("⏭️ Spine model already initialized, skipping...");
      return;
    }

    console.log("🎯 Initializing Spine Model...");

    // 先清理可能存在的旧实例
    cleanupSpineModel();

    // 首先加载 CSS
    loadSpineCSS();

    // 加载 Spine Web Player 运行时
    const loadSpineRuntime = () => {
      return new Promise((resolve, reject) => {
        if (typeof window.spine !== "undefined") {
          console.log("✅ Spine runtime already loaded");
          resolve();
          return;
        }

        console.log("📦 Loading Spine runtime...");
        const script = document.createElement("script");
        script.src =
          "https://unpkg.com/@esotericsoftware/spine-player@4.2.*/dist/iife/spine-player.min.js";
        script.onload = () => {
          console.log("✅ Spine runtime loaded from CDN");
          resolve();
        };
        script.onerror = (error) => {
          console.warn("⚠️ CDN failed, trying local fallback...");

          // 尝试本地回退
          const fallbackScript = document.createElement("script");
          fallbackScript.src = "/pio/static/spine-player.min.js";
          fallbackScript.onload = () => {
            console.log("✅ Spine runtime loaded from local fallback");
            resolve();
          };
          fallbackScript.onerror = () => {
            reject(new Error("Failed to load Spine runtime"));
          };
          document.head.appendChild(fallbackScript);
        };
        document.head.appendChild(script);
      });
    };

    // 等待 Spine 库加载
    const waitForSpine = () => {
      return new Promise((resolve, reject) => {
        let attempts = 0;
        const maxAttempts = 50;

        const check = () => {
          attempts++;
          if (typeof window.spine !== "undefined" && window.spine.SpinePlayer) {
            console.log("✅ Spine runtime loaded");
            resolve();
          } else if (attempts >= maxAttempts) {
            reject(new Error("Spine runtime loading timeout"));
          } else {
            setTimeout(check, 100);
          }
        };
        check();
      });
    };

    try {
      // 首先加载 Spine 运行时
      await loadSpineRuntime();

      // 然后等待 Spine 对象可用
      await waitForSpine();

      // 检查移动端显示设置
      if (
        spineModelConfig.responsive.hideOnMobile &&
        window.innerWidth <= spineModelConfig.responsive.mobileBreakpoint
      ) {
        const container = document.getElementById("spine-model-container");
        if (container) container.style.display = "none";
        return;
      }

      // 标记为已初始化
      window.spineModelInitialized = true;

      // 创建 SpinePlayer
      const player = new window.spine.SpinePlayer("spine-player-container", {
        skeleton: spineModelConfig.model.path,
        atlas: spineModelConfig.model.path.replace(".json", ".atlas"),
        animation: "idle",
        backgroundColor: "#00000000", // 透明背景
        showControls: false, // 隐藏控件
        alpha: true,
        premultipliedAlpha: false,
        success: (player) => {
          console.log("🎉 Spine model loaded successfully!");

          // 保存播放器实例引用
          window.spinePlayerInstance = player;

          // 初始化完成后设置默认姿态
          setTimeout(() => {
            if (player.skeleton) {
              try {
                player.skeleton.updateWorldTransform();
                player.skeleton.setToSetupPose();
              } catch (e) {
                console.warn("Error positioning skeleton:", e);
              }
            }
          }, 500);

          // 设置交互功能
          if (spineModelConfig.interactive.enabled) {
            const canvas = document.querySelector(
              "#spine-player-container canvas"
            );
            if (canvas) {
              canvas.addEventListener("click", () => {
                // 防抖处理：防止重复点击
                const currentTime = Date.now();
                if (isClickProcessing || currentTime - lastClickTime < 500) {
                  return; // 500ms 内重复点击忽略
                }

                isClickProcessing = true;
                lastClickTime = currentTime;

                // 随机播放点击动画
                const clickAnims =
                  spineModelConfig.interactive.clickAnimations ||
                  (spineModelConfig.interactive.clickAnimation
                    ? [spineModelConfig.interactive.clickAnimation]
                    : []);

                if (clickAnims.length > 0) {
                  try {
                    const randomClickAnim =
                      clickAnims[Math.floor(Math.random() * clickAnims.length)];
                    player.setAnimation(randomClickAnim, false);

                    // 动画播放完成后回到待机状态
                    setTimeout(() => {
                      const idleAnims =
                        spineModelConfig.interactive.idleAnimations;
                      const randomIdle =
                        idleAnims[Math.floor(Math.random() * idleAnims.length)];
                      player.setAnimation(randomIdle, true);
                    }, 2000);
                  } catch (e) {
                    console.warn("Failed to play click animation:", e);
                  }
                }

                // 显示随机消息
                const messages = spineModelConfig.interactive.clickMessages;
                if (messages && messages.length > 0) {
                  const randomMessage =
                    messages[Math.floor(Math.random() * messages.length)];
                  showMessage(randomMessage);
                }

                // 500ms 后重置防抖标志
                setTimeout(() => {
                  isClickProcessing = false;
                }, 500);
              });

              // 设置待机动画循环
              if (spineModelConfig.interactive.idleAnimations.length > 1) {
                setInterval(() => {
                  try {
                    const idleAnims =
                      spineModelConfig.interactive.idleAnimations;
                    const randomIdle =
                      idleAnims[Math.floor(Math.random() * idleAnims.length)];
                    player.setAnimation(randomIdle, true);
                  } catch (e) {
                    console.warn("Failed to play idle animation:", e);
                  }
                }, spineModelConfig.interactive.idleInterval);
              }
            }
          }

          // 添加拖拽功能
          const container = document.getElementById("spine-model-container");
          if (container) {
            let isDragging = false;
            let dragStart = { x: 0, y: 0 };
            let containerStart = { x: 0, y: 0 };

            // 鼠标事件
            container.addEventListener("mousedown", (e) => {
              if (e.button !== 0) return; // 只响应左键
              isDragging = true;
              dragStart = { x: e.clientX, y: e.clientY };

              const rect = container.getBoundingClientRect();
              containerStart = { x: rect.left, y: rect.top };

              container.style.cursor = "grabbing";
              e.preventDefault();
            });

            document.addEventListener("mousemove", (e) => {
              if (!isDragging) return;

              const deltaX = e.clientX - dragStart.x;
              const deltaY = e.clientY - dragStart.y;

              const newX = containerStart.x + deltaX;
              const newY = containerStart.y + deltaY;

              // 边界检查
              const maxX = window.innerWidth - container.offsetWidth;
              const maxY = window.innerHeight - container.offsetHeight;

              const clampedX = Math.max(0, Math.min(newX, maxX));
              const clampedY = Math.max(0, Math.min(newY, maxY));

              container.style.left = clampedX + "px";
              container.style.right = "auto";
              container.style.top = clampedY + "px";
              container.style.bottom = "auto";
            });

            document.addEventListener("mouseup", () => {
              if (isDragging) {
                isDragging = false;
                container.style.cursor = "grab";
              }
            });

            // 触摸事件（移动端支持）
            container.addEventListener("touchstart", (e) => {
              if (e.touches.length !== 1) return;
              isDragging = true;
              const touch = e.touches[0];
              dragStart = { x: touch.clientX, y: touch.clientY };

              const rect = container.getBoundingClientRect();
              containerStart = { x: rect.left, y: rect.top };

              e.preventDefault();
            });

            document.addEventListener("touchmove", (e) => {
              if (!isDragging || e.touches.length !== 1) return;

              const touch = e.touches[0];
              const deltaX = touch.clientX - dragStart.x;
              const deltaY = touch.clientY - dragStart.y;

              const newX = containerStart.x + deltaX;
              const newY = containerStart.y + deltaY;

              // 边界检查
              const maxX = window.innerWidth - container.offsetWidth;
              const maxY = window.innerHeight - container.offsetHeight;

              const clampedX = Math.max(0, Math.min(newX, maxX));
              const clampedY = Math.max(0, Math.min(newY, maxY));

              container.style.left = clampedX + "px";
              container.style.right = "auto";
              container.style.top = clampedY + "px";
              container.style.bottom = "auto";

              e.preventDefault();
            });

            document.addEventListener("touchend", () => {
              isDragging = false;
            });

            // 设置初始光标样式
            container.style.cursor = "grab";

            // 窗口大小变化时重新检查边界
            window.addEventListener("resize", () => {
              const rect = container.getBoundingClientRect();
              const maxX = window.innerWidth - container.offsetWidth;
              const maxY = window.innerHeight - container.offsetHeight;

              if (rect.left > maxX) {
                container.style.left = maxX + "px";
                container.style.right = "auto";
              }
              if (rect.top > maxY) {
                container.style.top = maxY + "px";
                container.style.bottom = "auto";
              }
            });
          }

          console.log("✅ Spine model setup complete!");
        },
        error: (player, reason) => {
          console.error("❌ Spine model loading error:", reason);

          const errorDiv = document.getElementById("spine-error");
          if (errorDiv) {
            errorDiv.style.display = "block";
            errorDiv.innerHTML = `
              <div style="color: #ff4444; padding: 20px; text-align: center; font-size: 14px;">
                <div>⚠️ Spine 模型加载失败</div>
                <div style="font-size: 12px; margin-top: 8px; color: #888;">${reason}</div>
              </div>
            `;
          }

          const canvas = document.getElementById("spine-canvas");
          if (canvas) canvas.style.display = "none";
        },
      });
    } catch (error) {
      console.error("Spine model initialization error:", error);

      // 重置初始化标志，允许重试
      window.spineModelInitialized = false;

      const errorDiv = document.getElementById("spine-error");
      if (errorDiv) {
        errorDiv.style.display = "block";
        errorDiv.innerHTML = `
          <div style="color: #ff4444; padding: 20px; text-align: center; font-size: 14px;">
            <div>⚠️ Spine 运行时加载失败</div>
            <div style="font-size: 12px; margin-top: 8px; color: #888;">${error instanceof Error ? error.message : "未知错误"}</div>
          </div>
        `;
      }
    }
  }

  // 监听页面卸载事件，清理资源
  window.addEventListener("beforeunload", cleanupSpineModel);

  // 监听 Swup 页面切换事件（如果使用了 Swup）
  if (typeof window.swup !== "undefined" && window.swup.hooks) {
    window.swup.hooks.on("content:replace", () => {
      // 只更新响应式显示，不重新创建模型
      setTimeout(() => {
        updateResponsiveDisplay();
      }, 100);
    });
  }

  // 监听 popstate 事件（浏览器前进后退）
  window.addEventListener("popstate", () => {
    setTimeout(() => {
      updateResponsiveDisplay();
    }, 100);
  });

  // 监听窗口大小变化
  window.addEventListener("resize", updateResponsiveDisplay);

  // 页面加载完成后初始化（只初始化一次）
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initSpineModel);
  } else {
    initSpineModel();
  }
</script>
